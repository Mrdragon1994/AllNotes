---
title: Relearn Regexp
date: 2020-03-26 14:05:40
tags:
- Regexp
categories:
- Regexp

---

# 重学正则

## 正则表达式简介

1. 尝尝鲜：

   ```js
   ^[0-9]+abc$
   ```

   - ^为匹配输入字符串开始的位置;
   - [0-9]匹配单个数字，+匹配一个或多个；
   - abc\$匹配字母abc并且需要以abc结尾的，\$为匹配输入字符串的结束位置

## 正则表达式语法

1. 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。
2. 正则表达式语言由两种基本字符类型组成，原义（正常）文本字符和元字符，元字符就是指那些在正则表达式中具有特殊含义的专用字符。

### 正则表达式的**元字符**(切记,非贪婪?只能用在限定符后面！！)

| 元字符       | 描述/备注/功能                                               |
| ------------ | ------------------------------------------------------------ |
| \            | 转义字符,如：n匹配字符n,\n匹配一个换行符,\\\匹配\\,\\(匹配( ；\\加上元字符，表示匹配元字符所使用的普通字符,\\其他字符，默认就是匹配该字符 |
| ^            | 匹配输入字符串的开始位置                                     |
| $            | 匹配输入字符串的结束位置                                     |
| *            | 匹配前面表达式0次，一次或多次，相当于{0,}                    |
| +            | 匹配前面的表达式一次或多次,相当于{1,}                        |
| ?            | 匹配前面的表达式0次或一次，相当于{0,1}                       |
| {n}          | 匹配指定字符n次                                              |
| {n,}         | 匹配指定字符至少n次                                          |
| {n,m}        | 匹配指定字符最少n次，最多m次                                 |
| ?            | 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。 |
| (pattern)    | 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到,使用 \$0…\$9 属性。要匹配圆括号字符，请使用 '\\(' 或 '\\)'。 |
| (?:pattern)  | 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (\|)来组合一个模式的各个部分是很有用。例如， 'industr(?:y\|ies)就是一个比'industry\|industries’更简单的表达式。 |
| (?=pattern)  | 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。**正向前瞻** |
| (?!pattern)  | 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。**负向前瞻** |
| (?<=pattern) | 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。**正向后顾** |
| (?<!pattern) | 反向否定预查，与正向否定预查类似，只是方向相反。**负向后顾** |
| x\|y         | 匹配x或y，z\|food能匹配‘z’或’‘food’，(z\|f)ood能匹配‘zood’或‘food’,(?:z\|f)ood能匹配‘zood’或‘food’,(?=z\|f)ood不能匹配到‘zood’或‘food’,(?<=z\|f)ood能匹配‘zood’或‘food’ |
| [xyz]        | 功能等同于(x\|y\|z)，就是匹配xyz中任意一个字符即可           |
| [^xyz]       | 不取xyz的其他字符                                            |
| [a-z]        | 匹配a到z这个范围的字符                                       |
| [^a-z]       | 不匹配a到z这个范围的字符                                     |
| \b           | 匹配一个单词的边界，如果正则表达式hi，那么history中的hi也会被匹配到，如果正则表达式是\bhi，history中的hi会被匹配到，如果正则表达式\bhi\b，那么只会精确匹配hi这个单词，而history中的hi就不会被匹配到了 |
| \B           | 与上面相反，他必须保证\B的位置是有字符的，如hi\B,那么history中的hi会被匹配到，但是hi就不能被匹配到了 |
| \d           | 匹配一个数字字符，等价于[0-9]                                |
| \D           | 匹配一个非数字字符，等价于[\^0-9]                            |
| \f           | 匹配一个换页符，等价于\x0c,\cL                               |
| \n           | 匹配一个换行符,等价于\x0a，\cJ                               |
| \r           | 匹配一个回车符，等价于\x0d,\cM                               |
| \cx          | 匹配一个control-x的字符，如\cM匹配一个control-M或者回车符，x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \s           | 匹配任何空白字符，等价于[\f\n\r\t\v]                         |
| \S           | 匹配任何非空白字符，等价于[\^\f\n\r\t\v]                     |
| \t           | 匹配一个制表符，等价于 \x09 和 \cI。                         |
| \v           | 匹配一个垂直制表符，等价于 \x0b 和 \cK。                     |
| \w           | 匹配字母，数字，下划线，等价于[A-Za-z0-9_]                   |
| \W           | 匹配非字母，数字，下划线，等价于[\^a-zA-Z0-9_]               |
| \num         | 该模式必须在出现()的情况下使用，然后\num需要匹配到和括号相同的字符，(\d*)\1，则1213不成立，1212成立 |
|              |                                                              |

### 正则表达式语法

#### 普通字符

1. 普通字符包括没有被显示指定为元字符的所有可打印和不可打印的字符，包括所有大写，小写，所有数字和所有标点符号和一些其他字符；

#### 非打印字符

1. 非打印字符也可以是正则表达式的组成部分，如下：

   | 字符 | 描述                                                  |
   | ---- | ----------------------------------------------------- |
   | \cx  | 匹配control-x的操作，如\cM匹配搭配control-M或者回车符 |
   | \f   | 换页符                                                |
   | \r   | 回车符                                                |
   | \n   | 换行符                                                |
   | \s   | 匹配所有空白字符，等价于：[ \f\n\r\t\v]               |
   | \S   | 匹配所有非空白字符，等价于：[ \^\f\n\r\t\v]           |
   | \t   | 制表符                                                |
   | \v   | 垂直制表符                                            |
   |      |                                                       |

#### 特殊字符

​	所谓特殊字符，就是一些具备特殊含义的字符，常见的特殊字符如下，我们如果想要匹配这些字符时，要加\\进行转义

​	

| 特殊字符 | 描述/备注/功能                                               |
| -------- | ------------------------------------------------------------ |
| $        | 匹配字符串的结尾处,若要匹配$,需要使用\\                      |
| ()       | 标记一个子表达式的开始和结束位置，若要使用()，需要使用转义\\ |
| *        | 表示匹配前面的子表达式出现0,1，多次                          |
| +        | 表示匹配前面的子表达式出现一次或多次                         |
| .        | 匹配除换行符\n之外的任何但字符                               |
| []       | 标记一个中括号的开始，在里面的值取的是或的关系，如果[a\|b]，则是匹配a,\|,b三个任意一个就行，同理，如果方括号中是[ \^]，那么其意思是空格和\^是或的关系 |
| ？       | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符         |
| \        | 将下一个字符标记为特殊字符                                   |
| ^        | 匹配输入字符串的开始位置，也就是从字符串的起始位置处开始匹配，而不是从中间某个位置匹配，如(abc\|bcd)可以匹配打ebcd中的bcd，但是^(abc\|bcd)不能匹配搭配ebcd中的bcd |
| {}       | 用来限定匹配的数量                                           |
| \|       | 表明或的关系                                                 |

#### 限定符

| 字符  | 描述/备注                              |
| ----- | -------------------------------------- |
| *     | 匹配前面出现的子表达式零次，一次或多次 |
| +     | 匹配前面出现的子表达式一次或多次       |
| ？    | 匹配前面出现的子表达式零次或一次       |
| {n}   | 精确匹配前面的子表达式出现n出现次      |
| {n,}  | 匹配前面的子表达式出现至少n次          |
| {n,m} | 匹配前面的子表达式出现至少n次，至多m次 |
|       |                                        |

#### 定位符

| 字符 | 描述                       |
| ---- | -------------------------- |
| ^    | 匹配字符串开始的位置       |
| \$   | 匹配字符串结束的位置       |
| \b   | 匹配到的单词不能有任何字符 |
| \B   | 匹配到的单词必需有字符     |

**PS：**不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 **^\*** 之类的表达式。



### 正则表达式运算符优先级

​	正则表达式是从左到右进行计算的，并遵循优先级顺序；相同优先级的从左到右进行运算不同优先级的运算先高后低，下面列表说明了从高到低的优先级顺序；

| 运算符                    | 描述/功能/备注 |
| ------------------------- | -------------- |
| \                         | 转义符         |
| (),(?:),(?=),[]           | 圆括号和方括号 |
| *，+，？，{}              | 限定符         |
| ^,$,\任何元字符，任何字符 | 定位符         |
| \|                        | 或             |



### 正则表达式匹配规则

1. 基本模式匹配

   ```js
   ^once
   匹配：once upon a time
   不匹配：There once was a man from NewYork
   ```

   ```js
   bucket$
   匹配：Who kept all of this cash in a bucket
   不匹配：buckets
   ```

   ```js
   once*?
   //实现的是e的可有可无
   ```

   There **onc**e was a man from **onc**e

   ```
   (once)??
   ```

   There once was a man from once

   非贪婪匹配，那么就实现？的0次匹配。

2. 字符族

   ```js
   [a-z] //匹配所有的小写字母 
   [A-Z] //匹配所有的大写字母 
   [a-zA-Z] //匹配所有的字母 
   [0-9] //匹配所有的数字 
   [0-9\.\-] //匹配所有的数字，句号和减号 
   [ \f\r\t\n] //匹配所有的白字符
   ```

3. 确定重复出现

   ```js
   ^[a-zA-Z0-9_]{1,}$      // 所有包含一个以上的字母、数字或下划线的字符串 
   ^[1-9][0-9]{0,}$        // 所有的正整数 
   ^\-{0,1}[0-9]{1,}$      // 所有的整数 
   ^[-]?[0-9]+\.?[0-9]+$   // 所有的浮点数
   ```



### 正则表达式示例

1. 简单表达式

   ```js
   a
   ```

   匹配：**a**b**a**

2. 中括号表达式

   在[]中，\会继续被视为转义符,

3. 分组

   需要注意以下两项的区别：

   ```js
   /^Chapter|Section [1-9][0-9]{0,1}$/
   ```

   该正则表达式会匹配行首是Chapter或者行尾是Section及跟在后面的任何数字

   如果输入： Chapter 22

   匹配到： Chapter 

   如果输入：Section 22

   匹配到： Section 22

   ```js
   /^(Chapter|Section) [1-9][0-9]{0,1}$/
   ```

   可以捕获开头是Chapter或Section开头后跟着数字的，但是这样做的正则匹配，会保存到内存中，我们可以使用?:来做不保存到内存中的做法，如下：

   ```js
   /^(?:Chapter|Section) [1-9][0-9]{0,1}$/
   ```

   ***探讨?:和?=的区别？***

   答：两者的共同点是都不会将捕获到的字符串保存到内存中，也就是后续无法通过\$来捕获它；

   ?: 匹配得到的结果包含pattern

   ?=匹配得到的结果不包含pattern

   ```js
   windows(?:98|2000|xp)
   //如果字符串是windows98
   //那么匹配到的结果就是windows98
   ```

   ```js
   windows(?=98|2000|xp)
   //如果字符串是windows98
   //那么匹配到的结果就是windows
   ```

   

   ![正则表达式非获取匹配](https://img-blog.csdn.net/20180420160417363?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYXNoYWdjc2Ru/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

   

   

   ```js
   windows(?:98|2000|xp)abc
   //字符串：windows98abc
   //匹配到的结果：windows98abc
   ```

   

   ```js
   windows(?=98|2000|xp)abc
   //字符串：windows98abc
   //匹配到的结果：无
   ```

   

   **PS：**
   
   ```js
   ([ ^]*)(\d*)
   //或者
   ([\^ ]*)(\d*)
   ```
   
   因为\^在[]中如果打头的话就是代表非
   
   方可正确匹配：
   
   ```java
   ^       123
   ```
   
   
